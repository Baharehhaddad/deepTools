#!/usr/bin/env python
import deeptools.heatmapper as heatmapper
import numpy as np
import argparse
import sys

def parse_arguments():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""
This tool subsets or reorders a file produced by computeMatrix by group and/or sample.

detailed help:

  subsetMatrix info -h

or

  subsetMatrix subset -h

or

  subsetMatrix filterStrand -h

or

  subsetMatrix rbind -h

or
  subsetMatrix cbind -h

""",
        epilog='example usages:\n'
               'subsetMatrix subset -m input.mat.gz -o output.mat.gz --group "group 1" "group 2" --samples "sample 3" "sample 10"\n\n'
               ' \n\n')

    subparsers = parser.add_subparsers(
        title='Commands',
        dest='command',
        metavar='')

    # info
    subparsers.add_parser(
        'info',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        parents=[infoArgs()],
        help="Print group and sample information",
        usage='An example usage is:\n  subsetMatrix info -m input.mat.gz\n\n')

    # subset
    subparsers.add_parser(
        'subset',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        parents=[infoArgs(), subsetArgs()],
        help="Actually subset the matrix. The group and sample orders are honored, so one can also reorder files.",
        usage='An example usage is:\n  subsetMatrix subset -m '
        'input.mat.gz -o output.mat.gz --groups "group 1" "group 2" '
        '--samples "sample 3" "sample 10"\n\n')

    # filterStrand
    subparsers.add_parser(
        'filterStrand',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        parents=[infoArgs(), filterStrandArgs()],
        help="Filter entries by strand.",
        usage='Example usage:\n  subsetMatrix filterStrand -m '
        'input.mat.gz -o output.mat.gz --strand +\n\n')

    # rbind
    subparsers.add_parser(
        'rbind',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        parents=[bindArgs()],
        help="merge multiple matrices by concatenating them head to tail. This assumes that the same samples are present in each in the same order. Multiple groups of regions are not supported.",
        usage='Example usage:\n  subsetMatrix rbind -m '
        'input1.mat.gz input2.mat.gz -o output.mat.gz\n\n')

    # cbind
    subparsers.add_parser(
        'cbind',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        parents=[bindArgs()],
        help="merge multiple matrices by concatenating them left to right. No assumptions are made about the row order. Regions not present in the first file specified are ignored. Regions missing in subsequent files will result in NAs.",
        usage='Example usage:\n  subsetMatrix cbind -m '
        'input1.mat.gz input2.mat.gz -o output.mat.gz\n\n')

    return parser


def bindArgs():
    parser = argparse.ArgumentParser(add_help=False)
    required = parser.add_argument_group('Required arguments')

    required.add_argument('--matrixFile', '-m',
                          help='Matrix files from the computeMatrix tool.',
                          nargs='+',
                          required=True)

    required.add_argument('--outFileName', '-o',
                          help='Output file name',
                          required=True)

    return parser


def infoArgs():
    parser = argparse.ArgumentParser(add_help=False)
    required = parser.add_argument_group('Required arguments')

    required.add_argument('--matrixFile', '-m',
                          help='Matrix file from the computeMatrix tool.',
                          required=True)

    return parser


def subsetArgs():
    parser = argparse.ArgumentParser(add_help=False)
    required = parser.add_argument_group('Required arguments')

    required.add_argument('--outFileName', '-o',
                          help='Output file name',
                          required=True)

    optional = parser.add_argument_group('Optional arguments')

    optional.add_argument('--groups',
                          nargs='+',
                          help="Groups to include. If none are specified then all will be included.")

    optional.add_argument('--samples',
                          nargs='+',
                          help="Samples to include. If none are specified then all will be included.")

    return parser


def filterStrandArgs():
    parser = argparse.ArgumentParser(add_help=False)
    required = parser.add_argument_group('Required arguments')

    required.add_argument('--outFileName', '-o',
                          help='Output file name',
                          required=True)

    required.add_argument('--strand', '-s',
                          help='Strand',
                          choices=['+', '-', '.'],
                          required=True)

    return parser


def printInfo(matrix):
    """
    Print the groups and samples
    """

    print("Groups:")
    for group in matrix.matrix.group_labels:
        print("\t{0}".format(group))

    print("Samples:")
    for sample in matrix.matrix.sample_labels:
        print("\t{0}".format(sample))


def getGroupBounds(args, matrix):
    """
    Given the group labels, return an indexing array and the resulting boundaries
    """
    bounds = matrix.parameters['group_boundaries']
    if args.groups is None:
        return range(0, matrix.matrix.matrix.shape[0]), np.array(bounds)
    else:
        o = list()
        obounds = [0]
        for group in args.groups:
            if group not in matrix.matrix.group_labels:
                sys.exit("Error: '{0}' is not a valid group\n".format(group))
            idx = matrix.matrix.group_labels.index(group)
            o.extend(range(bounds[idx], bounds[idx + 1]))
            obounds.append(bounds[idx + 1] - bounds[idx])
        return o, np.cumsum(obounds)


def getSampleBounds(args, matrix):
    """
    Given the sample labels, return an indexing array
    """
    bounds = matrix.parameters['sample_boundaries']
    if args.samples is None:
        return np.arange(0, matrix.matrix.matrix.shape[1])
    else:
        o = list()
        for sample in args.samples:
            if sample not in matrix.matrix.sample_labels:
                sys.exit("Error: '{0}' is not a valid sample\n".format(sample))
            idx = matrix.matrix.sample_labels.index(sample)
            o.extend(range(bounds[idx], bounds[idx + 1]))
        return o


def subsetRegions(hm, bounds):
    out = []
    for x in bounds:
        reg = hm.matrix.regions[x]
        # we need to add a list of [chrom, [(start, end), (start, end)], name, 0, strand, score)] 
        if isinstance(reg, dict):
            # This happens on occasion
            starts = reg["start"].split(",")
            starts = [int(x) for x in starts]
            ends = reg["end"].split(",")
            ends = [int(x) for x in ends]
            regs = [(x, y) for x, y in zip(starts, ends)]
            out.append([reg["chrom"], regs, reg["name"], 0, reg["strand"], reg["score"]])
        else:
            out.append(reg)
    return out


def filterHeatmap(hm, args):
    bounds = [0]
    regions = []
    keep = []
    total = 0
    for region in hm.matrix.regions:
        if region[4] == args.strand:
            keep.append(True)
            regions.append(region)
        else:
            keep.append(False)
    keep = np.array(keep)

    # Get the new bounds
    for idx in range(1, len(hm.matrix.group_boundaries)):
        i = np.sum(keep[hm.matrix.group_boundaries[idx - 1]:hm.matrix.group_boundaries[idx]])
        bounds.append(bounds[idx - 1] + i)

    hm.matrix.group_boundaries = bounds

    # subset the matrix
    hm.matrix.matrix = hm.matrix.matrix[keep,]
    hm.matrix.regions = regions


def insertMatrix(hm, hm2, groupName):
    """
    Given two heatmapper object and a region group name, insert the regions and
    values from hm2 for that group to the end of those for hm.
    """
    # get the bounds for hm
    idx = hm.parameters["group_labels"].index(groupName)
    hmEnd = hm.parameters["group_boundaries"][idx + 1]
    # get the bounds for hm2
    idx2 = hm2.parameters["group_labels"].index(groupName)
    hm2Start = hm2.parameters["group_boundaries"][idx2]
    hm2End = hm2.parameters["group_boundaries"][idx2 + 1]

    # Insert the subset hm2 into hm along axis 0
    hm.matrix.matrix = np.insert(hm.matrix.matrix, hmEnd, hm2.matrix.matrix[hm2Start:hm2End, :], axis=0)

    # Insert the regions
    hm.matrix.regions[hmEnd:hmEnd] = hm2.matrix.regions[hm2Start:hm2End]

    # Increase the group boundaries
    bounds = []
    for idx3, bound in enumerate(hm.parameters["group_boundaries"]):
        if idx3 > idx:
            bound += hm2End - hm2Start
        bounds.append(bound)
    hm.parameters["group_boundaries"] = bounds


def appendMatrix(hm, hm2, groupName):
    """
    Given two heatmapper objects and a region group name, append the values from
    that group in hm2 onto the end of hm.
    """
    # get the bounds for hm2
    idx2 = hm2.parameters["group_labels"].index(groupName)
    hm2Start = hm2.parameters["group_boundaries"][idx2]
    hm2End = hm2.parameters["group_boundaries"][idx2 + 1]

    # Append the matrix
    hm.matrix.matrix = np.concatenate([hm.matrix.matrix, hm2.matrix.matrix[hm2Start:hm2End, :]], axis=0)
    # Update the bounds
    hm.parameters["group_boundaries"].append(hm.parameters["group_boundaries"][-1] + hm2End - hm2Start)
    # Append the regions
    hm.matrix.regions.extend(hm2.matrix.regions[hm2Start:hm2End])


def rbindMatrices(hm, args):
    """
    This only supports a single group at this point

    It's assumed that the same samples are present in both and in the exact same order
    """
    hm2 = heatmapper.heatmapper()
    hm.read_matrix_file(args.matrixFile[0])
    for idx in range(1, len(args.matrixFile)):
        hm2.read_matrix_file(args.matrixFile[idx])
        for idx, group in enumerate(hm2.parameters["group_labels"]):
            if group in hm.parameters["group_labels"]:
                insertMatrix(hm, hm2, group)
            else:
                appendMatrix(hm, hm2, group)

    # Update the group boundaries attribute
    hm.matrix.group_labels = hm.parameters['group_labels']
    hm.matrix.group_boundaries = hm.parameters['group_boundaries']


def cbindMatrices(hm, args):
    """
    Bind columns from different matrices according to the group and region names

    Missing regions are left as NA
    """
    hm2 = heatmapper.heatmapper()

    # Make a dict of region name:row associations
    hm.read_matrix_file(args.matrixFile[0])
    d = dict({x: dict() for x in hm.parameters["group_labels"]})
    for idx, group in enumerate(hm.parameters["group_labels"]):
        s = hm.parameters["group_boundaries"][idx]
        e = hm.parameters["group_boundaries"][idx + 1]
        for idx2, reg in enumerate(hm.matrix.regions[s:e]):
            d[group][reg[2]] = idx2 + s

    # Iterate through the other matrices
    for idx in range(1, len(args.matrixFile)):
        hm2.read_matrix_file(args.matrixFile[idx])
        # Add the sample labels
        hm.parameters['sample_labels'].extend(hm2.parameters['sample_labels'])
        # Add the sample boundaries
        lens = [x + hm.parameters['sample_boundaries'][-1] for x in hm2.parameters['sample_boundaries']][1:]
        hm.parameters['sample_boundaries'].extend(lens)

        # Add on additional NA initialized columns
        ncol = hm.matrix.matrix.shape[1]
        hm.matrix.matrix = np.hstack((hm.matrix.matrix, np.empty(hm.matrix.matrix.shape)))
        hm.matrix.matrix[:,ncol:] = np.NAN

        # Update the values
        for idx2, group in enumerate(hm2.parameters["group_labels"]):
            if group not in d:
                continue
            s = hm2.parameters["group_boundaries"][idx2]
            e = hm2.parameters["group_boundaries"][idx2 + 1]
            for idx3, reg in enumerate(hm2.matrix.regions[s:e]):
                if reg[2] not in d[group]:
                    continue
                hm.matrix.matrix[d[group][reg[2]], ncol:] = hm2.matrix.matrix[s + idx3, :]

    # Update the sample parameters
    hm.matrix.sample_labels = hm.parameters['sample_labels']
    hm.matrix.sample_boundaries = hm.parameters['sample_boundaries']


def main():
    args = parse_arguments().parse_args()

    hm = heatmapper.heatmapper()
    if not isinstance(args.matrixFile, list):
        hm.read_matrix_file(args.matrixFile)

    if args.command == 'info':
        printInfo(hm)
    elif args.command == 'subset':
        sIdx = getSampleBounds(args, hm)
        gIdx, gBounds = getGroupBounds(args, hm)

        # groups
        hm.matrix.regions = subsetRegions(hm, gIdx)
        # matrix
        hm.matrix.matrix = hm.matrix.matrix[gIdx, :]
        hm.matrix.matrix = hm.matrix.matrix[:, sIdx]
        # boundaries
        if args.samples is None:
            args.samples = hm.matrix.sample_labels
        hm.matrix.sample_boundaries = hm.matrix.sample_boundaries[0:len(args.samples) + 1]
        hm.matrix.group_boundaries = gBounds.tolist()
        # labels
        hm.matrix.sample_labels = args.samples
        if args.groups is None:
            args.groups = hm.matrix.group_labels
        hm.matrix.group_labels = args.groups
        # save
        hm.save_matrix(args.outFileName)
    elif args.command == 'filterStrand':
        filterHeatmap(hm, args)
        hm.save_matrix(args.outFileName)
    elif args.command == 'rbind':
        rbindMatrices(hm, args)
        hm.save_matrix(args.outFileName)
    elif args.command == 'cbind':
        cbindMatrices(hm, args)
        hm.save_matrix(args.outFileName)
    else:
        sys.exit("Unknown command {0}!\n".format(args.command))


if __name__ == "__main__":
    main()
